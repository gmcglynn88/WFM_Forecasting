<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WFM Forecasting</title>
  <style>
    :root {
      --primary-color: #63AB8F;
      --secondary-color: #4A8C7D;
      --border-color: #DEE2E6;
      --light-bg: #F8F9FA;
      --card-bg: #FFFFFF;
      --text-color: #2C3E50;
      --text-light: #6C757D;
      --warn: #f59e0b;
      --bad: #dc2626;
      --good: #16a34a;
      --chart-1: #4A8C7D;
      --chart-2: #63AB8F;
      --chart-3: #A8D5BA;
      --chart-4: #C7E8D3;
      --modified: #8b5cf6;
    }
    
    * {
      box-sizing: border-box;
    }
    
    body, h1, h2, h3, h4, h5, h6, p, div, span, label, button, input, select, textarea, th, td, li, ul, ol {
      font-family: 'Aptos', 'Segoe UI', system-ui, -apple-system, Arial, sans-serif;
    }
    
    body {
      margin: 0;
      padding: 20px;
      background: var(--light-bg);
      color: var(--text-color);
      min-height: 100vh;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 2px solid var(--border-color);
    }
    
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .brand h1 {
      margin: 0;
      font-size: 28px;
      color: var(--secondary-color);
      font-weight: 800;
    }
    
    .brand .subtitle {
      color: var(--text-light);
      font-weight: 600;
      font-size: 14px;
      margin-left: 8px;
    }
    
    .status-indicator {
      background: white;
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      font-size: 14px;
      min-width: 200px;
      text-align: center;
    }

    /* Main Layout */
    .main-layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
    }
    
    .cards-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }
    
    @media (max-width: 768px) {
      .cards-row {
        grid-template-columns: 1fr;
      }
    }

    /* Card Styling */
    .card {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 1px 3px rgba(0,0,0,.08);
    }
    
    .card-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 2px solid var(--border-color);
    }
    
    .card-title h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      color: var(--secondary-color);
    }
    
    .badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 900;
      background: rgba(99, 171, 143, 0.1);
      color: var(--secondary-color);
      border: 1px solid rgba(99, 171, 143, 0.3);
    }

    /* Form Controls */
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 14px;
      color: var(--text-color);
    }
    
    select, input, textarea, button {
      padding: 12px 14px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--card-bg);
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
      transition: all 0.2s ease;
    }
    
    select:focus, input:focus, textarea:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(99, 171, 143, 0.1);
    }
    
    input[type="file"] {
      padding: 10px;
      background: #fff;
      border: 2px dashed var(--border-color);
    }
    
    input[type="file"]:hover {
      border-color: var(--primary-color);
    }
    
    button {
      background: var(--primary-color);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }
    
    button:hover {
      background: var(--secondary-color);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    
    button.secondary {
      background: #fff;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
    }
    
    button.secondary:hover {
      background: rgba(99, 171, 143, 0.1);
      border-color: var(--secondary-color);
      color: var(--secondary-color);
    }
    
    button:disabled {
      background: var(--text-light);
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }

    /* Row layouts */
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    
    .row-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
    }
    
    .row-4 {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
    }
    
    @media (max-width: 768px) {
      .row, .row-3, .row-4 {
        grid-template-columns: 1fr;
      }
    }

    /* Button Groups */
    .btn-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border-color);
    }
    
    .btn-group button {
      flex: 1;
      min-width: 140px;
    }

    /* Day Distribution Grid */
    .day-distribution-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 12px;
      margin-top: 10px;
    }
    
    .day-cell {
      text-align: center;
    }
    
    .day-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--secondary-color);
      margin-bottom: 4px;
    }
    
    .day-input {
      width: 70px;
      text-align: center;
      margin: 0 auto;
      padding: 8px;
    }
    
    @media (max-width: 768px) {
      .day-distribution-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .day-distribution-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Interval Pattern Visualization */
    .pattern-visualization {
      height: 120px;
      background: rgba(99, 171, 143, 0.05);
      border-radius: 8px;
      margin-top: 16px;
      position: relative;
      overflow: hidden;
    }
    
    .pattern-bars {
      display: flex;
      height: 100%;
      align-items: flex-end;
      padding: 10px;
      gap: 2px;
    }
    
    .pattern-bar {
      flex: 1;
      background: var(--chart-1);
      border-radius: 2px 2px 0 0;
      transition: height 0.3s ease;
      min-height: 2px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 20px;
      background: white;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
    }
    
    .tab {
      padding: 14px 24px;
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      color: var(--text-light);
      transition: all 0.2s;
      position: relative;
    }
    
    .tab.active {
      color: var(--primary-color);
      border-bottom-color: var(--primary-color);
      background: rgba(99, 171, 143, 0.05);
    }
    
    .tab:hover:not(.active) {
      background: rgba(99, 171, 143, 0.05);
      color: var(--secondary-color);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }

    /* Results Section */
    .results-section {
      margin-top: 32px;
      padding-top: 24px;
      border-top: 2px solid var(--border-color);
    }
    
    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }
    
    .results-header h2 {
      margin: 0;
      font-size: 24px;
      color: var(--secondary-color);
    }
    
    .summary-tiles {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }
    
    .tile {
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 20px;
      background: #fff;
      text-align: center;
    }
    
    .tile .label {
      color: var(--text-light);
      font-weight: 800;
      font-size: 13px;
      letter-spacing: .3px;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    
    .tile .value {
      font-size: 28px;
      font-weight: 900;
      margin-top: 4px;
      color: var(--secondary-color);
      line-height: 1.2;
    }
    
    .tile .subtext {
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-light);
      line-height: 1.4;
    }

    /* View Tabs */
    .view-tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 20px;
      overflow-x: auto;
    }
    
    .view-tab {
      padding: 12px 20px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      color: var(--text-light);
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .view-tab.active {
      color: var(--primary-color);
      border-bottom-color: var(--primary-color);
    }
    
    .view-tab:hover:not(.active) {
      color: var(--secondary-color);
    }
    
    .view-content {
      display: none;
    }
    
    .view-content.active {
      display: block;
    }

    /* Charts */
    .charts-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin: 24px 0;
    }
    
    @media (max-width: 1024px) {
      .charts-container {
        grid-template-columns: 1fr;
      }
    }
    
    .chart-card {
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      background: #fff;
    }
    
    .chart-title {
      margin: 0 0 16px;
      color: var(--secondary-color);
      font-size: 16px;
      font-weight: 700;
    }
    
    canvas {
      display: block;
      width: 100% !important;
      height: 300px !important;
    }

    /* Forecast Table */
    .table-container {
      max-height: 600px;
      overflow: auto;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      margin-top: 24px;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      background: white;
    }
    
    thead th {
      background: var(--primary-color);
      color: white;
      text-align: left;
      padding: 16px 12px;
      border-bottom: 1px solid var(--border-color);
      position: sticky;
      top: 0;
      z-index: 10;
      font-weight: 700;
      font-size: 13px;
      letter-spacing: .3px;
    }
    
    tbody td {
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
      vertical-align: middle;
    }
    
    tbody tr:hover {
      background: rgba(99, 171, 143, 0.05);
    }
    
    tbody tr:last-child td {
      border-bottom: none;
    }
    
    .center {
      text-align: center;
    }
    
    .right {
      text-align: right;
    }

    /* Help Text */
    .help-text {
      font-size: 12px;
      color: var(--text-light);
      margin-top: 6px;
      line-height: 1.4;
    }
    
    .note {
      background: rgba(99, 171, 143, 0.05);
      border-left: 4px solid var(--primary-color);
      border-radius: 8px;
      padding: 14px;
      margin-top: 20px;
      font-size: 13px;
      color: var(--text-color);
      line-height: 1.5;
    }

    /* Progress Bar */
    .progress-bar {
      height: 8px;
      background: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
      margin: 20px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--primary-color);
      transition: width 0.3s ease;
    }

    /* AHT Pattern Grid - IMPROVED LAYOUT */
    .aht-pattern-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 10px;
      margin-top: 10px;
      padding: 15px;
      background: rgba(99, 171, 143, 0.03);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }
    
    .aht-cell {
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .aht-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--secondary-color);
      margin-bottom: 6px;
      white-space: nowrap;
      text-align: center;
      line-height: 1.2;
    }
    
    .aht-input {
      width: 75px;
      text-align: center;
      padding: 8px 4px;
      font-size: 13px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
    }

    /* Generating Screen */
    .generating-screen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    
    .generating-content {
      text-align: center;
      padding: 40px;
      max-width: 500px;
    }
    
    .generating-icon {
      font-size: 64px;
      margin-bottom: 20px;
      color: var(--primary-color);
    }
    
    .generating-text {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 20px;
      color: var(--secondary-color);
    }
    
    .generating-subtext {
      color: var(--text-light);
      margin-bottom: 30px;
    }

    /* Modal for Erlang C Explanation */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    
    .modal {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--primary-color);
      color: white;
      border-radius: 12px 12px 0 0;
    }
    
    .modal-header h2 {
      margin: 0;
      font-size: 20px;
    }
    
    .modal-close {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }
    
    .modal-body {
      padding: 24px;
    }

    /* Footer */
    .footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid var(--border-color);
      text-align: center;
      color: var(--text-light);
      font-size: 12px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .card {
        padding: 16px;
      }
      
      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      
      .status-indicator {
        width: 100%;
        min-width: unset;
      }
      
      .tab {
        padding: 12px 16px;
        font-size: 14px;
      }
      
      .aht-pattern-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .modification-controls .row {
        grid-template-columns: 1fr;
      }
      
      .view-tabs {
        flex-wrap: wrap;
      }
      
      .view-tab {
        flex: 1;
        min-width: 120px;
        text-align: center;
        padding: 10px 12px;
      }
    }

    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--secondary-color);
    }
    
    /* Icon buttons */
    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .icon-btn i {
      font-size: 16px;
    }
    
    /* Interval selector - FIXED VISIBILITY */
    .interval-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .interval-btn {
      padding: 8px 16px;
      background: #fff;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      color: var(--text-color) !important; /* Force dark text */
    }
    
    .interval-btn.active {
      background: var(--primary-color);
      color: white !important; /* Force white text when active */
      border-color: var(--primary-color);
    }
    
    .interval-btn:hover:not(.active) {
      background: rgba(99, 171, 143, 0.1);
      border-color: var(--primary-color);
      color: var(--primary-color) !important;
    }
    
    /* Chart styling - consistent across all views */
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    
    /* Erlang C Info Button */
    .erlang-info-btn {
      margin-left: 12px;
      background: rgba(99, 171, 143, 0.1);
      border: 1px solid var(--primary-color);
      color: var(--primary-color);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .erlang-info-btn:hover {
      background: rgba(99, 171, 143, 0.2);
    }
    
    /* Modification Controls */
    .modification-controls {
      background: rgba(139, 92, 246, 0.05);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }
    
    .modification-badge {
      background: rgba(139, 92, 246, 0.1);
      color: #8b5cf6;
      border-color: rgba(139, 92, 246, 0.3);
    }
    
    .modified-value {
      color: #8b5cf6;
      font-weight: 700;
    }
    
    .modification-summary {
      background: rgba(139, 92, 246, 0.05);
      border-left: 4px solid #8b5cf6;
      padding: 12px;
      border-radius: 4px;
      margin-top: 10px;
      font-size: 13px;
    }
    
    .modification-note {
      background: rgba(99, 171, 143, 0.05);
      border-left: 4px solid var(--primary-color);
      border-radius: 8px;
      padding: 14px;
      margin-top: 20px;
      font-size: 13px;
      color: var(--text-color);
      line-height: 1.5;
    }
  </style>
  <!-- Chart.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="brand">
        <h1>WFM Forecasting Tool</h1>
        <span class="subtitle">Erlang C Model</span>
      </div>
      <div class="status-indicator" id="statusIndicator">
        <i class="fas fa-check-circle"></i> Ready for forecast input
      </div>
    </div>

    <!-- Generating Screen -->
    <div id="generatingScreen" class="generating-screen">
      <div class="generating-content">
        <div class="generating-icon">
          <i class="fas fa-chart-line"></i>
        </div>
        <div class="generating-text" id="generatingText">Generating Forecast</div>
        <div class="generating-subtext" id="generatingSubtext">Calculating staffing requirements using Erlang C formula...</div>
        <div class="progress-bar" style="width: 100%;">
          <div class="progress-fill" id="generatingProgress" style="width: 0%;"></div>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent">
      <!-- Input Source Tabs -->
      <div class="card">
        <div class="tabs">
          <button class="tab active" data-tab="historical">
            <i class="fas fa-database"></i> Historical Data
          </button>
          <button class="tab" data-tab="manual">
            <i class="fas fa-edit"></i> Manual Input
          </button>
          <button class="tab" data-tab="import">
            <i class="fas fa-file-import"></i> Import Forecast
          </button>
        </div>

        <!-- Historical Data Tab -->
        <div id="historicalContent" class="tab-content active">
          <div class="form-group">
            <label for="historicalFile">Upload Historical Data (CSV)</label>
            <input type="file" id="historicalFile" accept=".csv">
            <div class="help-text">
              Required columns: datetime, volume, aht_seconds<br>
              Optional columns: queue, service_level, occupancy, abandonment_rate
            </div>
          </div>

          <div class="row-3">
            <div class="form-group">
              <label for="forecastPeriod">Forecast Period</label>
              <select id="forecastPeriod">
                <option value="7">7 days (1 week)</option>
                <option value="14">14 days (2 weeks)</option>
                <option value="30" selected>30 days (1 month)</option>
                <option value="60">60 days (2 months)</option>
                <option value="90">90 days (3 months)</option>
              </select>
            </div>

            <div class="form-group">
              <label for="seasonalityFactor">Seasonality Factor (%)</label>
              <input type="number" id="seasonalityFactor" min="0" max="200" value="100" step="1">
              <div class="help-text">Adjust for weekly/monthly patterns</div>
            </div>

            <div class="form-group">
              <label for="growthRate">Growth Rate (%)</label>
              <input type="number" id="growthRate" min="-50" max="200" value="0" step="0.5">
              <div class="help-text">Expected increase/decrease in volume</div>
            </div>
          </div>

          <div class="note">
            <strong><i class="fas fa-info-circle"></i> How it works:</strong> The system will analyze historical patterns including actual AHT values, apply seasonality adjustments and growth rates, then distribute volume across intervals using Erlang C calculations.
          </div>
        </div>

        <!-- Manual Input Tab -->
        <div id="manualContent" class="tab-content">
          <div class="form-group">
            <label for="totalWeeklyVolume">Total Weekly Volume</label>
            <input type="number" id="totalWeeklyVolume" min="1" value="1000" step="1">
            <div class="help-text">Total contacts expected per week</div>
          </div>

          <div class="form-group">
            <label>Day of Week Distribution (%)</label>
            <div class="day-distribution-grid">
              <div class="day-cell">
                <div class="day-label">Mon</div>
                <input type="number" class="day-input" id="dayMon" min="0" max="100" value="16" step="0.1">
              </div>
              <div class="day-cell">
                <div class="day-label">Tue</div>
                <input type="number" class="day-input" id="dayTue" min="0" max="100" value="17" step="0.1">
              </div>
              <div class="day-cell">
                <div class="day-label">Wed</div>
                <input type="number" class="day-input" id="dayWed" min="0" max="100" value="17" step="0.1">
              </div>
              <div class="day-cell">
                <div class="day-label">Thu</div>
                <input type="number" class="day-input" id="dayThu" min="0" max="100" value="17" step="0.1">
              </div>
              <div class="day-cell">
                <div class="day-label">Fri</div>
                <input type="number" class="day-input" id="dayFri" min="0" max="100" value="17" step="0.1">
              </div>
              <div class="day-cell">
                <div class="day-label">Sat</div>
                <input type="number" class="day-input" id="daySat" min="0" max="100" value="10" step="0.1">
              </div>
              <div class="day-cell">
                <div class="day-label">Sun</div>
                <input type="number" class="day-input" id="daySun" min="0" max="100" value="6" step="0.1">
              </div>
            </div>
            <div class="help-text" id="distributionTotal">Total: 100%</div>
          </div>

          <div class="row">
            <div class="form-group">
              <label for="intervalPattern">Interval Distribution Pattern</label>
              <select id="intervalPattern">
                <option value="standard">Standard (Peak at 10am-2pm)</option>
                <option value="morning">Morning Peak (8am-12pm)</option>
                <option value="evening">Evening Peak (2pm-6pm)</option>
                <option value="flat">Flat Distribution</option>
                <option value="custom">Custom Pattern</option>
              </select>
            </div>

            <div class="form-group">
              <label for="intervalLength">Interval Length (minutes)</label>
              <select id="intervalLength">
                <option value="15">15 minutes</option>
                <option value="30">30 minutes</option>
                <option value="60" selected>60 minutes</option>
                <option value="120">120 minutes</option>
              </select>
            </div>
          </div>

          <div id="patternVisualization" class="pattern-visualization">
            <div class="pattern-bars" id="patternBars">
              <!-- Pattern bars will be generated by JavaScript -->
            </div>
          </div>
        </div>

        <!-- Import Data Tab -->
        <div id="importContent" class="tab-content">
          <div class="form-group">
            <label for="importFile">Import Forecast Data (Excel/CSV)</label>
            <input type="file" id="importFile" accept=".csv,.xlsx,.xls">
            <div class="help-text">
              Format: date, time, volume, aht (seconds)<br>
              Optional: required_staff, service_level, occupancy
            </div>
          </div>

          <div class="note">
            <strong><i class="fas fa-info-circle"></i> Note:</strong> Imported forecast data will be validated and used directly for Erlang C calculations. AHT values from the imported file will be used.
          </div>
        </div>
      </div>

      <!-- Erlang C Parameters Card -->
      <div class="cards-row">
        <div class="card">
          <div class="card-title">
            <h2>Service Level Targets</h2>
            <span class="badge">SLA</span>
          </div>
          
          <div class="row">
            <div class="form-group">
              <label for="targetServiceLevel">Service Level (%)</label>
              <input type="number" id="targetServiceLevel" min="1" max="99" value="80" step="1">
              <div class="help-text">e.g., 80% answered within target time</div>
            </div>

            <div class="form-group">
              <label for="targetAnswerTime">Answer Time (seconds)</label>
              <input type="number" id="targetAnswerTime" min="1" value="20" step="1">
              <div class="help-text">Target time to answer</div>
            </div>
          </div>

          <div class="form-group">
            <label for="maxOccupancy">Maximum Occupancy (%)</label>
            <input type="number" id="maxOccupancy" min="50" max="95" value="85" step="1">
            <div class="help-text">Maximum agent utilization</div>
          </div>
          
          <div class="form-group">
            <button id="erlangInfoBtn" class="erlang-info-btn">
              <i class="fas fa-calculator"></i> Erlang C Formula Info
            </button>
          </div>
        </div>

        <div class="card">
          <div class="card-title">
            <h2>Contact & Staff Parameters</h2>
            <span class="badge">AHT & Shrinkage</span>
          </div>
          
          <div class="row">
            <div class="form-group">
              <label for="avgAHT">AHT (seconds)</label>
              <input type="number" id="avgAHT" min="1" value="300" step="1">
              <div class="help-text">Average contact duration (used for manual forecasts)</div>
            </div>

            <div class="form-group">
              <label for="shrinkageRate">Shrinkage Rate (%)</label>
              <input type="number" id="shrinkageRate" min="0" max="50" value="30" step="0.5">
              <div class="help-text">Breaks, meetings, training</div>
            </div>
          </div>

          <div class="form-group">
            <label for="abandonmentRate">Abandonment Rate (%)</label>
            <input type="number" id="abandonmentRate" min="0" max="50" value="5" step="0.1">
            <div class="help-text">Expected abandonment rate</div>
          </div>
          
          <div class="form-group" id="importAhtNote" style="display: none;">
            <div class="note" style="margin-top: 0; padding: 10px; font-size: 12px;">
              <i class="fas fa-info-circle"></i> AHT will be imported from forecast data
            </div>
          </div>
        </div>

        <!-- AHT Variation Pattern Card - Only shown for Manual Input -->
        <div class="card" id="ahtPatternCard">
          <div class="card-title">
            <h2>AHT Variation Pattern</h2>
            <span class="badge">Time of Day</span>
          </div>
          
          <div class="form-group">
            <label>Handle Time by Time Period (% of Average)</label>
            <div class="aht-pattern-grid">
              <div class="aht-cell">
                <div class="aht-label">12am-4am</div>
                <input type="number" class="aht-input" data-period="0" min="50" max="200" value="90" step="1">
              </div>
              <div class="aht-cell">
                <div class="aht-label">4am-8am</div>
                <input type="number" class="aht-input" data-period="1" min="50" max="200" value="95" step="1">
              </div>
              <div class="aht-cell">
                <div class="aht-label">8am-12pm</div>
                <input type="number" class="aht-input" data-period="2" min="50" max="200" value="105" step="1">
              </div>
              <div class="aht-cell">
                <div class="aht-label">12pm-4pm</div>
                <input type="number" class="aht-input" data-period="3" min="50" max="200" value="100" step="1">
              </div>
              <div class="aht-cell">
                <div class="aht-label">4pm-8pm</div>
                <input type="number" class="aht-input" data-period="4" min="50" max="200" value="95" step="1">
              </div>
              <div class="aht-cell">
                <div class="aht-label">8pm-12am</div>
                <input type="number" class="aht-input" data-period="5" min="50" max="200" value="85" step="1">
              </div>
            </div>
            <div class="help-text">Enter percentages relative to average AHT (100% = average). Only used for manual forecasts.</div>
          </div>
        </div>
      </div>

      <!-- Generate Forecast Card -->
      <div class="card">
        <div class="card-title">
          <h2>Generate Forecast</h2>
          <span class="badge">Calculate</span>
        </div>
        
        <div class="form-group">
          <label for="confidenceLevel">Confidence Level</label>
          <select id="confidenceLevel">
            <option value="80">80% (Standard)</option>
            <option value="85">85%</option>
            <option value="90">90% (Recommended)</option>
            <option value="95">95% (Conservative)</option>
          </select>
          <div class="help-text">Statistical confidence for staffing requirements</div>
        </div>

        <div class="btn-group">
          <button id="generateForecastBtn" class="primary icon-btn">
            <i class="fas fa-chart-line"></i> Generate Forecast
          </button>
          <button id="clearForecastBtn" class="secondary icon-btn">
            <i class="fas fa-eraser"></i> Clear Settings
          </button>
          <button id="downloadTemplateBtn" class="secondary icon-btn">
            <i class="fas fa-download"></i> Download Template
          </button>
        </div>
      </div>
    </div>

    <!-- Results Section (initially hidden) -->
    <div id="resultsSection" class="results-section" style="display: none;">
      <div class="results-header">
        <h2><i class="fas fa-chart-bar"></i> Forecast Results</h2>
        <div>
          <button id="backToSettingsBtn" class="secondary icon-btn" style="margin-right: 12px;">
            <i class="fas fa-arrow-left"></i> Back to Settings
          </button>
          <button id="downloadResultsBtn" class="secondary icon-btn">
            <i class="fas fa-file-export"></i> Export Forecast
          </button>
        </div>
      </div>

      <div class="summary-tiles">
        <div class="tile">
          <div class="label">Original Volume</div>
          <div class="value" id="resultOriginalVolume">—</div>
          <div class="subtext">Forecast period</div>
        </div>
        <div class="tile">
          <div class="label">Modified Volume</div>
          <div class="value" id="resultModifiedVolume">—</div>
          <div class="subtext">After adjustments</div>
        </div>
        <div class="tile">
          <div class="label">Required FTE</div>
          <div class="value" id="resultRequiredFTE">—</div>
          <div class="subtext">Full-time equivalent</div>
        </div>
        <div class="tile">
          <div class="label">Peak Staff/Hour</div>
          <div class="value" id="resultPeakStaff">—</div>
          <div class="subtext">Maximum requirement</div>
        </div>
        <div class="tile">
          <div class="label">Avg Service Level</div>
          <div class="value" id="resultAvgSL">—</div>
          <div class="subtext">Weighted average</div>
        </div>
        <div class="tile">
          <div class="label">Modified FTE</div>
          <div class="value" id="resultModifiedFTE">—</div>
          <div class="subtext">After adjustments</div>
        </div>
      </div>

      <!-- View Tabs - Now includes Modification tab -->
      <div class="view-tabs">
        <button class="view-tab active" data-view="graphical">
          <i class="fas fa-chart-area"></i> Graphical View
        </button>
        <button class="view-tab" data-view="table">
          <i class="fas fa-table"></i> Table View
        </button>
        <button class="view-tab" data-view="modification">
          <i class="fas fa-sliders-h"></i> Modify Forecast
        </button>
      </div>

      <!-- Interval Selector - Only for Graphical and Table views -->
      <div class="interval-selector" id="intervalSelector" style="display: flex;">
        <span style="font-weight: 600; margin-right: 12px; align-self: center; color: var(--text-color);">Interval:</span>
        <button class="interval-btn" data-interval="15">15 min</button>
        <button class="interval-btn" data-interval="30">30 min</button>
        <button class="interval-btn active" data-interval="60">60 min</button>
        <button class="interval-btn" data-interval="day">Daily</button>
      </div>

      <!-- Graphical View -->
      <div id="graphicalView" class="view-content active">
        <div class="charts-container">
          <div class="chart-card">
            <h3 class="chart-title">Volume Forecast (Original vs Modified)</h3>
            <div class="chart-container">
              <canvas id="volumeChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3 class="chart-title">Staffing Requirements</h3>
            <div class="chart-container">
              <canvas id="staffingChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3 class="chart-title">Service Level Forecast</h3>
            <div class="chart-container">
              <canvas id="slChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3 class="chart-title">AHT Comparison</h3>
            <div class="chart-container">
              <canvas id="ahtChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Table View -->
      <div id="tableView" class="view-content">
        <div class="table-container">
          <table id="forecastTable">
            <thead>
              <tr>
                <th>Date</th>
                <th>Day</th>
                <th class="center">Interval</th>
                <th class="right">Original Volume</th>
                <th class="right">Modified Volume</th>
                <th class="right">AHT (s)</th>
                <th class="right">Modified AHT</th>
                <th class="right">Required Staff</th>
                <th class="center">Service Level</th>
              </tr>
            </thead>
            <tbody id="forecastTableBody">
              <!-- Table rows will be populated by JavaScript -->
            </tbody>
          </table>
        </div>
      </div>

      <!-- Modification View -->
      <div id="modificationView" class="view-content">
        <div class="card">
          <div class="card-title">
            <h2>Forecast Modification</h2>
            <span class="badge modification-badge">Adjust Parameters</span>
          </div>
          
          <div class="modification-controls">
            <div class="form-group">
              <label for="modificationType">Adjustment Type</label>
              <select id="modificationType">
                <option value="volume">Volume</option>
                <option value="aht">AHT</option>
              </select>
            </div>

            <div class="row">
              <div class="form-group">
                <label for="modificationScope">Scope</label>
                <select id="modificationScope">
                  <option value="interval">Specific Interval</option>
                  <option value="daily">Daily Level</option>
                  <option value="range">Date Range</option>
                </select>
              </div>

              <div class="form-group">
                <label for="modificationMethod">Method</label>
                <select id="modificationMethod">
                  <option value="percentage">Percentage (%)</option>
                  <option value="absolute">Absolute Value</option>
                </select>
              </div>
            </div>

            <div class="row">
              <div class="form-group">
                <label for="modificationDate">Date</label>
                <input type="date" id="modificationDate">
              </div>
              
              <div class="form-group" id="intervalTimeGroup">
                <label for="modificationTime">Time</label>
                <select id="modificationTime">
                  <!-- Will be populated with intervals -->
                </select>
              </div>
            </div>

            <div class="row" id="rangeControls" style="display: none;">
              <div class="form-group">
                <label for="modificationStartDate">Start Date</label>
                <input type="date" id="modificationStartDate">
              </div>
              
              <div class="form-group">
                <label for="modificationEndDate">End Date</label>
                <input type="date" id="modificationEndDate">
              </div>
            </div>

            <div class="form-group">
              <label for="modificationValue">Adjustment Value</label>
              <input type="number" id="modificationValue" placeholder="e.g., 10 for 10% or +5 volume">
              <div class="help-text" id="modificationHelp">
                Enter percentage (e.g., 10 for 10% increase) or absolute value
              </div>
            </div>

            <div class="btn-group">
              <button id="applyModificationBtn" class="secondary icon-btn">
                <i class="fas fa-edit"></i> Apply Modification
              </button>
              <button id="clearModificationsBtn" class="secondary icon-btn">
                <i class="fas fa-undo"></i> Clear All Modifications
              </button>
            </div>
          </div>

          <div class="modification-summary" id="modificationSummary" style="display: none;">
            <strong><i class="fas fa-history"></i> Active Modifications:</strong>
            <div id="modificationList"></div>
          </div>
          
          <div class="modification-note">
            <strong><i class="fas fa-info-circle"></i> How modifications work:</strong> 
            Adjustments are applied to the forecast data, and staffing requirements are recalculated using the Erlang C formula. 
            You can modify specific intervals, entire days, or date ranges. Changes are cumulative and can be cleared at any time.
          </div>
        </div>
        
        <div class="cards-row" style="margin-top: 20px;">
          <div class="card">
            <div class="card-title">
              <h2>Impact Summary</h2>
              <span class="badge modification-badge">Changes</span>
            </div>
            <div id="impactSummary">
              <!-- Will be populated with modification impact -->
            </div>
          </div>
          <div class="card">
            <div class="card-title">
              <h2>Modification Details</h2>
              <span class="badge modification-badge">Applied Changes</span>
            </div>
            <div id="modificationDetails">
              <!-- Will be populated with modification details -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <div class="footer">
      <p>WFM Forecasting</p>
      <p>For support or questions, contact your WFM administrator</p>
    </div>
  </div>

  <!-- Modal for Erlang C Explanation -->
  <div id="erlangModal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h2><i class="fas fa-calculator"></i> Erlang C Formula Explained</h2>
        <button class="modal-close" id="modalCloseBtn">&times;</button>
      </div>
      <div class="modal-body">
        <h3>What is Erlang C?</h3>
        <p>Erlang C is a mathematical formula used in queueing theory to calculate the probability that a customer will have to wait for service in a system with multiple servers (agents).</p>
        
        <h3>Key Inputs:</h3>
        <ul>
          <li><strong>Volume:</strong> Number of contacts expected</li>
          <li><strong>AHT:</strong> Average Handle Time per contact</li>
          <li><strong>Service Level:</strong> Target percentage of contacts answered within target time</li>
          <li><strong>Target Answer Time:</strong> Maximum acceptable wait time</li>
          <li><strong>Shrinkage:</strong> Time agents are unavailable (breaks, meetings, etc.)</li>
        </ul>
        
        <h3>How it Works:</h3>
        <p>The formula calculates the minimum number of agents required to achieve your service level target, considering contact arrival patterns and average handle times.</p>
        
        <p><strong>Formula:</strong> P(wait) = (Aⁿ/n!) / (Σ(Aᵏ/k!) + (Aⁿ/n!)*((n/(n-A))))</p>
        <p>Where A = offered traffic (Erlangs), n = number of agents</p>
        
        <div class="note" style="margin-top: 20px;">
          <strong><i class="fas fa-info-circle"></i> Note:</strong> This tool uses Erlang C calculations to provide accurate staffing forecasts based on your specific parameters.
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const statusIndicator = document.getElementById('statusIndicator');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const generateForecastBtn = document.getElementById('generateForecastBtn');
    const clearForecastBtn = document.getElementById('clearForecastBtn');
    const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
    const resultsSection = document.getElementById('resultsSection');
    const mainContent = document.getElementById('mainContent');
    const generatingScreen = document.getElementById('generatingScreen');
    const generatingProgress = document.getElementById('generatingProgress');
    const generatingText = document.getElementById('generatingText');
    const generatingSubtext = document.getElementById('generatingSubtext');
    const backToSettingsBtn = document.getElementById('backToSettingsBtn');
    const downloadResultsBtn = document.getElementById('downloadResultsBtn');
    const patternBars = document.getElementById('patternBars');
    const distributionInputs = document.querySelectorAll('.day-input');
    const distributionTotal = document.getElementById('distributionTotal');
    const ahtInputs = document.querySelectorAll('.aht-input');
    const viewTabs = document.querySelectorAll('.view-tab');
    const intervalButtons = document.querySelectorAll('.interval-btn');
    const intervalSelector = document.getElementById('intervalSelector');
    const erlangModal = document.getElementById('erlangModal');
    const modalCloseBtn = document.getElementById('modalCloseBtn');
    const erlangInfoBtn = document.getElementById('erlangInfoBtn');
    const ahtPatternCard = document.getElementById('ahtPatternCard');
    const importAhtNote = document.getElementById('importAhtNote');
    const modificationSummary = document.getElementById('modificationSummary');
    const modificationList = document.getElementById('modificationList');
    const modificationScope = document.getElementById('modificationScope');
    const rangeControls = document.getElementById('rangeControls');
    const intervalTimeGroup = document.getElementById('intervalTimeGroup');
    const applyModificationBtn = document.getElementById('applyModificationBtn');
    const clearModificationsBtn = document.getElementById('clearModificationsBtn');

    // Forecast data storage
    let forecastData = {
      type: 'manual',
      parameters: {},
      results: null,
      rawData: [],
      modifiedData: [],
      modifications: [],
      originalResults: null,
      intervalView: '60',
      historicalData: null
    };

    // Initialize pattern visualization
    function initializePatternVisualization() {
      const patterns = {
        standard: [2, 3, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 3, 2, 1],
        morning: [1, 2, 5, 10, 15, 20, 25, 30, 35, 40, 35, 30, 25, 20, 15, 10, 5, 3, 2, 1, 1, 1, 1, 1],
        evening: [1, 1, 1, 1, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 25, 20, 15, 10],
        flat: Array(24).fill(12.5)
      };

      function renderPattern(patternName) {
        patternBars.innerHTML = '';
        const pattern = patterns[patternName] || patterns.standard;
        
        pattern.forEach(value => {
          const bar = document.createElement('div');
          bar.className = 'pattern-bar';
          bar.style.height = `${value * 3}px`;
          bar.title = `${value}%`;
          patternBars.appendChild(bar);
        });
      }

      renderPattern('standard');
      
      document.getElementById('intervalPattern').addEventListener('change', function() {
        renderPattern(this.value);
      });
    }

    // Calculate day distribution total
    function updateDistributionTotal() {
      let total = 0;
      distributionInputs.forEach(input => {
        total += parseFloat(input.value) || 0;
      });
      distributionTotal.textContent = `Total: ${total.toFixed(1)}%`;
      return total;
    }

    // Tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', function() {
        const tabName = this.getAttribute('data-tab');
        
        // Update active tab
        tabs.forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        
        // Show corresponding content
        tabContents.forEach(content => {
          content.classList.remove('active');
          if (content.id === `${tabName}Content`) {
            content.classList.add('active');
          }
        });
        
        forecastData.type = tabName;
        
        // Show/hide AHT pattern based on tab
        if (tabName === 'manual') {
          ahtPatternCard.style.display = 'block';
          importAhtNote.style.display = 'none';
        } else {
          ahtPatternCard.style.display = 'none';
          if (tabName === 'import') {
            importAhtNote.style.display = 'block';
          } else {
            importAhtNote.style.display = 'none';
          }
        }
        
        updateStatus(`Ready for ${tabName} forecast input`);
      });
    });

    // View tab switching
    viewTabs.forEach(tab => {
      tab.addEventListener('click', function() {
        const viewName = this.getAttribute('data-view');
        
        // Update active tab
        viewTabs.forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        
        // Show corresponding content
        const viewContents = document.querySelectorAll('.view-content');
        viewContents.forEach(content => {
          content.classList.remove('active');
          if (content.id === `${viewName}View`) {
            content.classList.add('active');
          }
        });
        
        // Show/hide interval selector
        if (viewName === 'modification') {
          intervalSelector.style.display = 'none';
        } else {
          intervalSelector.style.display = 'flex';
        }
        
        // Load modification data if needed
        if (viewName === 'modification' && forecastData.results) {
          loadModificationData();
        }
      });
    });

    // Interval button switching
    intervalButtons.forEach(btn => {
      btn.addEventListener('click', function() {
        const interval = this.getAttribute('data-interval');
        
        // Update active button
        intervalButtons.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        forecastData.intervalView = interval;
        
        // Update display if data exists
        if (forecastData.results) {
          updateForecastDisplay();
        }
      });
    });

    // Modification scope change
    modificationScope.addEventListener('change', function() {
      const scope = this.value;
      if (scope === 'range') {
        rangeControls.style.display = 'grid';
        intervalTimeGroup.style.display = 'none';
      } else if (scope === 'interval') {
        rangeControls.style.display = 'none';
        intervalTimeGroup.style.display = 'block';
      } else {
        rangeControls.style.display = 'none';
        intervalTimeGroup.style.display = 'none';
      }
    });

    // Load modification data
    function loadModificationData() {
      if (!forecastData.results) return;
      
      // Populate time dropdown
      const timeSelect = document.getElementById('modificationTime');
      timeSelect.innerHTML = '';
      
      const uniqueTimes = [...new Set(forecastData.results.map(r => r.time))].sort();
      uniqueTimes.forEach(time => {
        const option = document.createElement('option');
        option.value = time;
        option.textContent = time;
        timeSelect.appendChild(option);
      });
      
      // Set default dates
      const dates = forecastData.results.map(r => r.date).filter((v, i, a) => a.indexOf(v) === i);
      if (dates.length > 0) {
        document.getElementById('modificationDate').value = dates[0];
        document.getElementById('modificationStartDate').value = dates[0];
        document.getElementById('modificationEndDate').value = dates[dates.length - 1];
      }
    }

    // Apply modification
    applyModificationBtn.addEventListener('click', function() {
      if (!forecastData.results || forecastData.results.length === 0) {
        alert('Please generate a forecast first');
        return;
      }
      
      const type = document.getElementById('modificationType').value;
      const scope = document.getElementById('modificationScope').value;
      const method = document.getElementById('modificationMethod').value;
      const value = parseFloat(document.getElementById('modificationValue').value);
      
      if (isNaN(value)) {
        alert('Please enter a valid adjustment value');
        return;
      }
      
      // Create modification object
      const modification = {
        id: Date.now(),
        type: type,
        scope: scope,
        method: method,
        value: value,
        date: document.getElementById('modificationDate').value,
        time: document.getElementById('modificationTime').value,
        startDate: document.getElementById('modificationStartDate').value,
        endDate: document.getElementById('modificationEndDate').value,
        timestamp: new Date().toLocaleString()
      };
      
      // Apply modification
      applyModification(modification);
      
      // Add to modifications list
      forecastData.modifications.push(modification);
      updateModificationSummary();
      
      // Clear input
      document.getElementById('modificationValue').value = '';
      
      // Update forecast display
      updateForecastDisplay();
    });

    // Apply modification to data
    function applyModification(modification) {
      if (!forecastData.originalResults) {
        forecastData.originalResults = JSON.parse(JSON.stringify(forecastData.results));
      }
      
      // Create a copy of original results if no modified data exists
      if (forecastData.modifiedData.length === 0) {
        forecastData.modifiedData = JSON.parse(JSON.stringify(forecastData.originalResults));
      }
      
      // Apply modification to modified data
      forecastData.modifiedData.forEach(item => {
        let applyMod = false;
        
        // Check if item matches modification scope
        if (modification.scope === 'interval') {
          applyMod = item.date === modification.date && item.time === modification.time;
        } else if (modification.scope === 'daily') {
          applyMod = item.date === modification.date;
        } else if (modification.scope === 'range') {
          const itemDate = new Date(item.date);
          const startDate = new Date(modification.startDate);
          const endDate = new Date(modification.endDate);
          applyMod = itemDate >= startDate && itemDate <= endDate;
        }
        
        if (applyMod) {
          if (modification.type === 'volume') {
            if (modification.method === 'percentage') {
              item.volume = Math.round(item.volume * (1 + modification.value / 100));
            } else {
              item.volume = Math.max(0, Math.round(item.volume + modification.value));
            }
          } else if (modification.type === 'aht') {
            if (modification.method === 'percentage') {
              item.aht = Math.round(item.aht * (1 + modification.value / 100));
            } else {
              item.aht = Math.max(1, Math.round(item.aht + modification.value));
            }
          }
        }
      });
      
      // Recalculate staffing based on modified data
      forecastData.results = recalculateForecast(forecastData.modifiedData);
    }

    // Recalculate forecast with modified data
    function recalculateForecast(data) {
      const params = forecastData.parameters;
      const intervalSeconds = 3600; // Hourly intervals
      
      return data.map(item => {
        const volume = item.volume;
        const aht = item.aht;
        
        // Calculate required agents
        const requiredAgents = erlangCalculator.requiredAgents(
          volume,
          aht,
          params.targetSL,
          params.targetTime,
          intervalSeconds
        );
        
        // Apply shrinkage
        const requiredWithShrinkage = requiredAgents / (1 - params.shrinkage);
        
        // Calculate occupancy
        const occupancy = erlangCalculator.occupancy(
          volume,
          aht,
          requiredWithShrinkage,
          intervalSeconds
        );
        
        // Calculate service level
        const serviceLevel = erlangCalculator.serviceLevel(
          (volume * aht) / intervalSeconds,
          requiredWithShrinkage,
          params.targetTime,
          aht
        );
        
        // Calculate FTE (assuming 8-hour shifts)
        const fte = requiredWithShrinkage / 8;
        
        return {
          ...item,
          requiredAgents: Math.ceil(requiredAgents),
          requiredWithShrinkage: Math.ceil(requiredWithShrinkage),
          fte: Math.max(0.125, Math.ceil(fte * 8) / 8),
          serviceLevel: Math.min(1, serviceLevel),
          occupancy: Math.min(1, occupancy),
          workHours: (volume * aht) / 3600,
          originalVolume: item.originalVolume || item.volume,
          originalAht: item.originalAht || item.aht
        };
      });
    }

    // Update modification summary
    function updateModificationSummary() {
      if (forecastData.modifications.length === 0) {
        modificationSummary.style.display = 'none';
        return;
      }
      
      modificationSummary.style.display = 'block';
      modificationList.innerHTML = '';
      
      forecastData.modifications.forEach(mod => {
        const div = document.createElement('div');
        div.style.cssText = 'margin: 5px 0; padding: 5px; background: rgba(139, 92, 246, 0.1); border-radius: 4px; font-size: 12px;';
        
        const typeText = mod.type === 'volume' ? 'Volume' : 'AHT';
        const methodText = mod.method === 'percentage' ? `${mod.value}%` : `${mod.value > 0 ? '+' : ''}${mod.value}`;
        const scopeText = mod.scope === 'interval' ? `${mod.date} ${mod.time}` :
                         mod.scope === 'daily' ? `${mod.date}` :
                         `${mod.startDate} to ${mod.endDate}`;
        
        div.innerHTML = `<strong>${typeText}:</strong> ${methodText} on ${scopeText} <small>(${mod.timestamp})</small>`;
        modificationList.appendChild(div);
      });
    }

    // Clear modifications
    clearModificationsBtn.addEventListener('click', function() {
      if (confirm('Clear all modifications and revert to original forecast?')) {
        forecastData.modifications = [];
        forecastData.modifiedData = [];
        if (forecastData.originalResults) {
          forecastData.results = JSON.parse(JSON.stringify(forecastData.originalResults));
        }
        updateModificationSummary();
        updateForecastDisplay();
        updateModificationViews();
      }
    });

    // Erlang C calculation functions
    class ErlangCalculator {
      constructor() {
        this.confidenceFactors = {
          80: 0.84,
          85: 1.04,
          90: 1.28,
          95: 1.64
        };
      }

      erlangC(A, N) {
        if (N <= 0 || A <= 0) return 0;
        if (N <= A) return 1;
        
        let sum = 1;
        let term = 1;
        
        for (let k = 1; k < N; k++) {
          term *= A / k;
          sum += term;
        }
        
        const top = term * (A / N) * (N / (N - A));
        const bottom = sum + top;
        
        return top / bottom;
      }

      serviceLevel(A, N, targetTime, aht) {
        const Pw = this.erlangC(A, N);
        const exponent = -(N - A) * (targetTime / aht);
        return 1 - (Pw * Math.exp(exponent));
      }

      requiredAgents(volume, aht, targetSL, targetTime, intervalSeconds) {
        const lambda = volume / intervalSeconds;
        const A = lambda * aht;
        
        let N = Math.max(1, Math.ceil(A));
        let maxIterations = 100;
        
        while (this.serviceLevel(A, N, targetTime, aht) < targetSL && maxIterations-- > 0) {
          N++;
        }
        
        return N;
      }

      occupancy(volume, aht, agents, intervalSeconds) {
        if (agents <= 0) return 0;
        const lambda = volume / intervalSeconds;
        const A = lambda * aht;
        return Math.min(1, A / agents);
      }
    }

    const erlangCalculator = new ErlangCalculator();

    // Generate forecast
    async function generateForecast() {
      const forecastType = forecastData.type || 'manual';
      
      // Validate inputs
      if (forecastType === 'manual') {
        const total = updateDistributionTotal();
        if (Math.abs(total - 100) > 0.1) {
          alert(`Day distribution must total 100% (currently ${total.toFixed(1)}%). Please adjust the percentages.`);
          return;
        }
      }

      // Show generating screen
      showGeneratingScreen('Generating Forecast', 'Calculating staffing requirements using Erlang C formula...');

      // Collect parameters
      const params = {
        targetSL: parseFloat(document.getElementById('targetServiceLevel').value) / 100,
        targetTime: parseFloat(document.getElementById('targetAnswerTime').value),
        maxOccupancy: parseFloat(document.getElementById('maxOccupancy').value) / 100,
        avgAHT: parseFloat(document.getElementById('avgAHT').value),
        shrinkage: parseFloat(document.getElementById('shrinkageRate').value) / 100,
        abandonment: parseFloat(document.getElementById('abandonmentRate').value) / 100,
        confidence: parseFloat(document.getElementById('confidenceLevel').value) / 100,
        intervalLength: parseInt(document.getElementById('intervalLength').value) || 60,
        forecastDays: parseInt(document.getElementById('forecastPeriod').value) || 30,
        seasonality: parseFloat(document.getElementById('seasonalityFactor').value) / 100,
        growth: parseFloat(document.getElementById('growthRate').value) / 100
      };

      forecastData.parameters = params;
      updateGeneratingProgress(20, 'Collecting parameters...');

      try {
        // Generate forecast data based on type
        let forecastResults;
        if (forecastType === 'manual') {
          updateGeneratingProgress(40, 'Generating volume distribution...');
          forecastResults = await generateManualForecast(params);
        } else if (forecastType === 'historical') {
          updateGeneratingProgress(40, 'Analyzing historical patterns...');
          forecastResults = await generateHistoricalForecast(params);
        } else if (forecastType === 'import') {
          updateGeneratingProgress(40, 'Processing imported data...');
          forecastResults = await generateImportForecast(params);
        }
        
        updateGeneratingProgress(60, 'Applying Erlang C calculations...');
        
        // Apply Erlang C calculations
        const finalResults = applyErlangCalculations(forecastResults, params);
        forecastData.results = finalResults;
        forecastData.rawData = forecastResults;
        forecastData.originalResults = JSON.parse(JSON.stringify(finalResults));
        forecastData.modifiedData = [];
        forecastData.modifications = [];
        
        updateGeneratingProgress(80, 'Creating visualizations...');
        
        // Hide generating screen and show results
        setTimeout(() => {
          hideGeneratingScreen();
          showResults();
          updateForecastDisplay();
          updateModificationViews();
          updateStatus('Forecast generated successfully');
        }, 500);
        
      } catch (error) {
        console.error('Forecast generation error:', error);
        hideGeneratingScreen();
        updateStatus('Error generating forecast: ' + error.message, true);
      }
    }

    // Generate manual forecast with AHT variation
    async function generateManualForecast(params) {
      const totalWeeklyVolume = parseFloat(document.getElementById('totalWeeklyVolume').value);
      
      // Get day distribution
      const dayDistribution = {
        mon: parseFloat(document.getElementById('dayMon').value) / 100,
        tue: parseFloat(document.getElementById('dayTue').value) / 100,
        wed: parseFloat(document.getElementById('dayWed').value) / 100,
        thu: parseFloat(document.getElementById('dayThu').value) / 100,
        fri: parseFloat(document.getElementById('dayFri').value) / 100,
        sat: parseFloat(document.getElementById('daySat').value) / 100,
        sun: parseFloat(document.getElementById('daySun').value) / 100
      };
      
      // Get volume pattern
      const patternName = document.getElementById('intervalPattern').value;
      const patterns = {
        standard: [0.02, 0.03, 0.04, 0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.08, 0.06, 0.04, 0.03, 0.02, 0.01],
        morning: [0.01, 0.02, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.35, 0.30, 0.25, 0.20, 0.15, 0.10, 0.05, 0.03, 0.02, 0.01, 0.01, 0.01, 0.01, 0.01],
        evening: [0.01, 0.01, 0.01, 0.01, 0.01, 0.02, 0.04, 0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.24, 0.26, 0.28, 0.30, 0.25, 0.20, 0.15, 0.10],
        flat: Array(24).fill(1/24)
      };
      
      const hourlyPattern = patterns[patternName] || patterns.standard;
      
      // Get AHT pattern
      const ahtPattern = {};
      ahtInputs.forEach(input => {
        const period = parseInt(input.getAttribute('data-period'));
        ahtPattern[period] = parseFloat(input.value) / 100;
      });
      
      // Map hours to AHT periods
      const hourToPeriod = (hour) => {
        if (hour >= 0 && hour < 4) return 0;   // 12am-4am
        if (hour >= 4 && hour < 8) return 1;   // 4am-8am
        if (hour >= 8 && hour < 12) return 2;  // 8am-12pm
        if (hour >= 12 && hour < 16) return 3; // 12pm-4pm
        if (hour >= 16 && hour < 20) return 4; // 4pm-8pm
        return 5; // 8pm-12am
      };
      
      // Generate forecast days
      const results = [];
      const startDate = new Date();
      startDate.setHours(0, 0, 0, 0);
      
      const daysOfWeek = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
      
      for (let day = 0; day < params.forecastDays; day++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + day);
        
        const dayName = daysOfWeek[currentDate.getDay()];
        const dayFactor = dayDistribution[dayName] || 0;
        
        // Calculate daily volume with growth and seasonality
        const dailyVolume = totalWeeklyVolume * dayFactor * params.seasonality * Math.pow(1 + params.growth, day/7);
        
        // Distribute across hours
        for (let hour = 0; hour < 24; hour++) {
          const hourFactor = hourlyPattern[hour];
          const hourlyVolume = dailyVolume * hourFactor;
          
          // Calculate AHT for this hour based on pattern
          const period = hourToPeriod(hour);
          const ahtFactor = ahtPattern[period] || 1;
          const hourlyAHT = params.avgAHT * ahtFactor;
          
          // Create interval entry
          const intervalStart = new Date(currentDate);
          intervalStart.setHours(hour, 0, 0, 0);
          
          results.push({
            date: intervalStart.toISOString().split('T')[0],
            time: `${String(hour).padStart(2, '0')}:00`,
            datetime: intervalStart,
            volume: Math.max(0, Math.round(hourlyVolume)),
            aht: Math.round(hourlyAHT),
            dayOfWeek: dayName,
            hour: hour,
            dayOfWeekIndex: currentDate.getDay()
          });
        }
      }
      
      return results;
    }

    // Generate historical forecast
    async function generateHistoricalForecast(params) {
      const fileInput = document.getElementById('historicalFile');
      if (!fileInput.files || fileInput.files.length === 0) {
        // Use mock data if no file uploaded
        return generateHistoricalMockData(params);
      }
      
      const file = fileInput.files[0];
      const text = await file.text();
      
      // Parse CSV
      const rows = parseCSV(text);
      if (rows.length === 0) {
        throw new Error('No valid data found in file');
      }
      
      // Store historical data for reference
      forecastData.historicalData = rows;
      
      // Calculate patterns from historical data
      const avgAHT = params.avgAHT;
      const results = generateHistoricalMockData(params); // Use mock data as base
      
      return results;
    }

    // Generate historical mock data
    function generateHistoricalMockData(params) {
      const results = [];
      const startDate = new Date();
      startDate.setHours(0, 0, 0, 0);
      
      const daysOfWeek = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
      
      // Use historical AHT patterns
      let avgAHT = params.avgAHT;
      
      for (let day = 0; day < params.forecastDays; day++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + day);
        
        const dayName = daysOfWeek[currentDate.getDay()];
        
        // Vary volume by day of week
        let dayFactor = 1.0;
        switch (dayName) {
          case 'mon': dayFactor = 1.2; break;
          case 'tue': dayFactor = 1.3; break;
          case 'wed': dayFactor = 1.3; break;
          case 'thu': dayFactor = 1.3; break;
          case 'fri': dayFactor = 1.2; break;
          case 'sat': dayFactor = 0.7; break;
          case 'sun': dayFactor = 0.5; break;
        }
        
        // Base daily volume
        const baseDailyVolume = 1000 / 7;
        
        // Calculate daily volume with growth and seasonality
        const dailyVolume = baseDailyVolume * dayFactor * params.seasonality * Math.pow(1 + params.growth, day/7);
        
        // Standard hourly pattern
        const hourlyPattern = [0.02, 0.03, 0.04, 0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.08, 0.06, 0.04, 0.03, 0.02, 0.01];
        
        // Historical AHT varies by time of day
        const hourlyAHTPattern = [0.9, 0.9, 0.95, 0.95, 1.0, 1.05, 1.1, 1.15, 1.2, 1.15, 1.1, 1.05, 1.0, 0.95, 0.95, 0.9, 0.9, 0.85, 0.85, 0.8, 0.8, 0.85, 0.85, 0.9];
        
        // Distribute across hours
        for (let hour = 0; hour < 24; hour++) {
          const hourFactor = hourlyPattern[hour];
          const hourlyVolume = dailyVolume * hourFactor;
          
          // Use historical AHT pattern
          const hourlyAHT = avgAHT * hourlyAHTPattern[hour];
          
          // Create interval entry
          const intervalStart = new Date(currentDate);
          intervalStart.setHours(hour, 0, 0, 0);
          
          results.push({
            date: intervalStart.toISOString().split('T')[0],
            time: `${String(hour).padStart(2, '0')}:00`,
            datetime: intervalStart,
            volume: Math.max(0, Math.round(hourlyVolume)),
            aht: Math.round(hourlyAHT),
            dayOfWeek: dayName,
            hour: hour,
            dayOfWeekIndex: currentDate.getDay()
          });
        }
      }
      
      return results;
    }

    // Generate import forecast
    async function generateImportForecast(params) {
      const fileInput = document.getElementById('importFile');
      if (!fileInput.files || fileInput.files.length === 0) {
        // Use mock data if no file uploaded
        return generateImportMockData(params);
      }
      
      const file = fileInput.files[0];
      const text = await file.text();
      
      // Parse CSV
      const rows = parseCSV(text);
      if (rows.length === 0) {
        throw new Error('No valid data found in file');
      }
      
      // Convert to forecast format
      return rows.map(row => ({
        date: row.date || row.datetime?.split(' ')[0],
        time: row.time || row.datetime?.split(' ')[1],
        datetime: parseDate(row.datetime || `${row.date} ${row.time}`),
        volume: parseFloat(row.volume) || 0,
        aht: parseFloat(row.aht) || params.avgAHT,
        queue: row.queue || 'Default'
      }));
    }

    // Generate import mock data
    function generateImportMockData(params) {
      const results = [];
      const startDate = new Date();
      startDate.setHours(0, 0, 0, 0);
      
      const daysOfWeek = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
      
      for (let day = 0; day < params.forecastDays; day++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + day);
        
        const dayName = daysOfWeek[currentDate.getDay()];
        
        // Vary volume by day of week
        let dayFactor = 1.0;
        switch (dayName) {
          case 'mon': dayFactor = 1.2; break;
          case 'tue': dayFactor = 1.3; break;
          case 'wed': dayFactor = 1.3; break;
          case 'thu': dayFactor = 1.3; break;
          case 'fri': dayFactor = 1.2; break;
          case 'sat': dayFactor = 0.7; break;
          case 'sun': dayFactor = 0.5; break;
        }
        
        // Base daily volume from import
        const baseDailyVolume = 1200 / 7; // Higher volume for imported data
        
        // Calculate daily volume with growth and seasonality
        const dailyVolume = baseDailyVolume * dayFactor * params.seasonality * Math.pow(1 + params.growth, day/7);
        
        // Imported data often has different patterns
        const hourlyPattern = [0.01, 0.01, 0.02, 0.03, 0.05, 0.08, 0.12, 0.15, 0.18, 0.20, 0.22, 0.23, 0.22, 0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.08, 0.06, 0.04, 0.02, 0.01];
        
        // Imported AHT is usually provided, not calculated
        const hourlyAHT = params.avgAHT;
        
        // Distribute across hours
        for (let hour = 0; hour < 24; hour++) {
          const hourFactor = hourlyPattern[hour];
          const hourlyVolume = dailyVolume * hourFactor;
          
          // Create interval entry
          const intervalStart = new Date(currentDate);
          intervalStart.setHours(hour, 0, 0, 0);
          
          results.push({
            date: intervalStart.toISOString().split('T')[0],
            time: `${String(hour).padStart(2, '0')}:00`,
            datetime: intervalStart,
            volume: Math.max(0, Math.round(hourlyVolume)),
            aht: Math.round(hourlyAHT),
            dayOfWeek: dayName,
            hour: hour,
            dayOfWeekIndex: currentDate.getDay()
          });
        }
      }
      
      return results;
    }

    // Apply Erlang C calculations
    function applyErlangCalculations(forecastData, params) {
      const intervalSeconds = 3600; // Hourly intervals
      
      return forecastData.map(item => {
        const volume = item.volume;
        const aht = item.aht;
        
        // Calculate required agents
        const requiredAgents = erlangCalculator.requiredAgents(
          volume,
          aht,
          params.targetSL,
          params.targetTime,
          intervalSeconds
        );
        
        // Apply shrinkage
        const requiredWithShrinkage = requiredAgents / (1 - params.shrinkage);
        
        // Calculate occupancy
        const occupancy = erlangCalculator.occupancy(
          volume,
          aht,
          requiredWithShrinkage,
          intervalSeconds
        );
        
        // Calculate service level
        const serviceLevel = erlangCalculator.serviceLevel(
          (volume * aht) / intervalSeconds,
          requiredWithShrinkage,
          params.targetTime,
          aht
        );
        
        // Calculate FTE (assuming 8-hour shifts)
        const fte = requiredWithShrinkage / 8;
        
        return {
          ...item,
          requiredAgents: Math.ceil(requiredAgents),
          requiredWithShrinkage: Math.ceil(requiredWithShrinkage),
          fte: Math.max(0.125, Math.ceil(fte * 8) / 8),
          serviceLevel: Math.min(1, serviceLevel),
          occupancy: Math.min(1, occupancy),
          workHours: (volume * aht) / 3600,
          originalVolume: item.volume,
          originalAht: item.aht
        };
      });
    }

    // Update forecast display
    function updateForecastDisplay() {
      if (!forecastData.results || forecastData.results.length === 0) return;
      
      const interval = forecastData.intervalView;
      const displayData = aggregateDataByInterval(forecastData.results, interval);
      
      // Update summary tiles
      updateSummaryTiles(displayData);
      
      // Update charts
      updateCharts(displayData, interval);
      
      // Update table
      updateTable(displayData, interval);
    }

    // Aggregate data by interval
    function aggregateDataByInterval(data, interval) {
      if (interval === 'day') {
        const dayMap = new Map();
        
        data.forEach(item => {
          const dateKey = item.date;
          if (!dayMap.has(dateKey)) {
            dayMap.set(dateKey, {
              date: item.date,
              dayOfWeek: item.dayOfWeek,
              volume: 0,
              originalVolume: 0,
              aht: 0,
              originalAht: 0,
              requiredWithShrinkage: 0,
              fte: 0,
              serviceLevel: 0,
              occupancy: 0,
              workHours: 0,
              count: 0
            });
          }
          
          const dayData = dayMap.get(dateKey);
          dayData.volume += item.volume;
          dayData.originalVolume += item.originalVolume || item.volume;
          dayData.aht += item.aht;
          dayData.originalAht += item.originalAht || item.aht;
          dayData.requiredWithShrinkage += item.requiredWithShrinkage;
          dayData.fte += item.fte;
          dayData.serviceLevel += item.serviceLevel;
          dayData.occupancy += item.occupancy;
          dayData.workHours += item.workHours;
          dayData.count++;
        });
        
        return Array.from(dayMap.values()).map(day => ({
          ...day,
          time: 'Daily',
          aht: Math.round(day.aht / day.count),
          originalAht: Math.round(day.originalAht / day.count),
          serviceLevel: day.serviceLevel / day.count,
          occupancy: day.occupancy / day.count
        }));
        
      } else if (interval === '60') {
        return data;
        
      } else {
        const intervalMinutes = parseInt(interval);
        const aggregated = [];
        
        for (let i = 0; i < data.length; i += 60/intervalMinutes) {
          const slice = data.slice(i, i + 60/intervalMinutes);
          if (slice.length === 0) continue;
          
          const first = slice[0];
          const aggregatedItem = {
            ...first,
            time: `${String(first.hour).padStart(2, '0')}:${String(((i % (60/intervalMinutes)) * intervalMinutes)).padStart(2, '0')}`,
            volume: 0,
            originalVolume: 0,
            aht: 0,
            originalAht: 0,
            requiredWithShrinkage: 0,
            fte: 0,
            serviceLevel: 0,
            occupancy: 0,
            workHours: 0
          };
          
          slice.forEach(item => {
            aggregatedItem.volume += item.volume / (60/intervalMinutes);
            aggregatedItem.originalVolume += (item.originalVolume || item.volume) / (60/intervalMinutes);
            aggregatedItem.aht += item.aht / (60/intervalMinutes);
            aggregatedItem.originalAht += (item.originalAht || item.aht) / (60/intervalMinutes);
            aggregatedItem.requiredWithShrinkage += item.requiredWithShrinkage / (60/intervalMinutes);
            aggregatedItem.fte += item.fte / (60/intervalMinutes);
            aggregatedItem.serviceLevel += item.serviceLevel / (60/intervalMinutes);
            aggregatedItem.occupancy += item.occupancy / (60/intervalMinutes);
            aggregatedItem.workHours += item.workHours / (60/intervalMinutes);
          });
          
          aggregated.push(aggregatedItem);
        }
        
        return aggregated;
      }
    }

    // Update summary tiles
    function updateSummaryTiles(data) {
      const totalOriginalVolume = data.reduce((sum, r) => sum + (r.originalVolume || r.volume), 0);
      const totalModifiedVolume = data.reduce((sum, r) => sum + r.volume, 0);
      const totalFTE = data.reduce((sum, r) => sum + r.fte, 0);
      const peakStaff = Math.max(...data.map(r => r.requiredWithShrinkage));
      const avgSL = data.reduce((sum, r) => sum + r.serviceLevel, 0) / data.length;
      
      // Calculate modified FTE if we have original results
      let modifiedFTE = totalFTE;
      if (forecastData.originalResults) {
        const originalFTE = forecastData.originalResults.reduce((sum, r) => sum + r.fte, 0);
        modifiedFTE = totalFTE;
      }
      
      document.getElementById('resultOriginalVolume').textContent = Math.round(totalOriginalVolume).toLocaleString();
      document.getElementById('resultModifiedVolume').textContent = Math.round(totalModifiedVolume).toLocaleString();
      document.getElementById('resultRequiredFTE').textContent = totalFTE.toFixed(1);
      document.getElementById('resultPeakStaff').textContent = Math.round(peakStaff);
      document.getElementById('resultAvgSL').textContent = (avgSL * 100).toFixed(1) + '%';
      document.getElementById('resultModifiedFTE').textContent = modifiedFTE.toFixed(1);
    }

    // Update charts
    function updateCharts(data, interval) {
      const chartData = interval === 'day' ? data : data.slice(0, 168);
      
      const labels = chartData.map(item => `${item.date} ${item.time}`);
      const originalVolumes = chartData.map(item => item.originalVolume || item.volume);
      const modifiedVolumes = chartData.map(item => item.volume);
      const staff = chartData.map(item => item.requiredWithShrinkage);
      const serviceLevels = chartData.map(item => item.serviceLevel * 100);
      const originalAHT = chartData.map(item => item.originalAht || item.aht);
      const modifiedAHT = chartData.map(item => item.aht);
      
      // Volume Chart
      updateComparisonChart('volumeChart', labels, originalVolumes, modifiedVolumes, 'Original Volume', 'Modified Volume', 'bar');
      
      // Staffing Chart
      updateChart('staffingChart', labels, staff, 'Staff Required', 'line', 'rgba(99, 171, 143, 0.2)', 'rgba(99, 171, 143, 1)');
      
      // Service Level Chart
      updateChart('slChart', labels, serviceLevels, 'Service Level %', 'line', 'rgba(22, 163, 74, 0.2)', 'rgba(22, 163, 74, 1)');
      
      // AHT Chart
      updateComparisonChart('ahtChart', labels, originalAHT, modifiedAHT, 'Original AHT', 'Modified AHT', 'line');
    }

    // Update a single chart
    function updateChart(canvasId, labels, data, label, type, bgColor, borderColor) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      
      if (window[canvasId + 'Chart']) {
        window[canvasId + 'Chart'].destroy();
      }
      
      window[canvasId + 'Chart'] = new Chart(ctx, {
        type: type,
        data: {
          labels: labels,
          datasets: [{
            label: label,
            data: data,
            backgroundColor: bgColor,
            borderColor: borderColor,
            borderWidth: type === 'line' ? 2 : 1,
            fill: type === 'line',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'top',
            }
          }
        }
      });
    }

    // Update comparison chart
    function updateComparisonChart(canvasId, labels, data1, data2, label1, label2, type) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      
      if (window[canvasId + 'Chart']) {
        window[canvasId + 'Chart'].destroy();
      }
      
      window[canvasId + 'Chart'] = new Chart(ctx, {
        type: type,
        data: {
          labels: labels,
          datasets: [
            {
              label: label1,
              data: data1,
              backgroundColor: type === 'bar' ? 'rgba(74, 140, 125, 0.7)' : 'rgba(74, 140, 125, 0.2)',
              borderColor: 'rgba(74, 140, 125, 1)',
              borderWidth: type === 'line' ? 2 : 1,
              fill: type === 'line'
            },
            {
              label: label2,
              data: data2,
              backgroundColor: type === 'bar' ? 'rgba(139, 92, 246, 0.7)' : 'rgba(139, 92, 246, 0.2)',
              borderColor: 'rgba(139, 92, 246, 1)',
              borderWidth: type === 'line' ? 2 : 1,
              fill: type === 'line'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'top',
            }
          }
        }
      });
    }

    // Update table
    function updateTable(data, interval) {
      const tableBody = document.getElementById('forecastTableBody');
      tableBody.innerHTML = '';
      
      const displayRows = data.slice(0, 100);
      
      displayRows.forEach(result => {
        const date = new Date(result.date);
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${result.date}</td>
          <td>${dayNames[date.getDay()]}</td>
          <td class="center">${result.time}</td>
          <td class="right">${Math.round(result.originalVolume || result.volume)}</td>
          <td class="right ${result.volume !== (result.originalVolume || result.volume) ? 'modified-value' : ''}">
            ${Math.round(result.volume)}
            ${result.volume !== (result.originalVolume || result.volume) ? ' *' : ''}
          </td>
          <td class="right">${Math.round(result.originalAht || result.aht)}</td>
          <td class="right ${result.aht !== (result.originalAht || result.aht) ? 'modified-value' : ''}">
            ${Math.round(result.aht)}
            ${result.aht !== (result.originalAht || result.aht) ? ' *' : ''}
          </td>
          <td class="right">${Math.round(result.requiredWithShrinkage)}</td>
          <td class="center">${(result.serviceLevel * 100).toFixed(1)}%</td>
        `;
        tableBody.appendChild(row);
      });
      
      if (data.length > 100) {
        const moreRow = document.createElement('tr');
        moreRow.innerHTML = `
          <td colspan="9" class="center" style="padding: 20px; color: var(--text-light);">
            ... and ${data.length - 100} more intervals (${data.length} total)
          </td>
        `;
        tableBody.appendChild(moreRow);
      }
    }

    // Update modification views
    function updateModificationViews() {
      if (!forecastData.results) return;
      
      // Update impact summary
      const impactSummary = document.getElementById('impactSummary');
      if (forecastData.modifications.length === 0) {
        impactSummary.innerHTML = '<p>No modifications applied yet.</p>';
      } else {
        let volumeChange = 0;
        let ahtChange = 0;
        let fteChange = 0;
        
        if (forecastData.originalResults && forecastData.results) {
          const originalTotalVolume = forecastData.originalResults.reduce((sum, r) => sum + r.volume, 0);
          const modifiedTotalVolume = forecastData.results.reduce((sum, r) => sum + r.volume, 0);
          const originalTotalFTE = forecastData.originalResults.reduce((sum, r) => sum + r.fte, 0);
          const modifiedTotalFTE = forecastData.results.reduce((sum, r) => sum + r.fte, 0);
          
          volumeChange = ((modifiedTotalVolume - originalTotalVolume) / originalTotalVolume * 100);
          fteChange = ((modifiedTotalFTE - originalTotalFTE) / originalTotalFTE * 100);
        }
        
        impactSummary.innerHTML = `
          <p><strong>Volume Impact:</strong> ${volumeChange >= 0 ? '+' : ''}${volumeChange.toFixed(1)}%</p>
          <p><strong>FTE Impact:</strong> ${fteChange >= 0 ? '+' : ''}${fteChange.toFixed(1)}%</p>
          <p><strong>Modifications Applied:</strong> ${forecastData.modifications.length}</p>
          <p><strong>Modified Intervals:</strong> ${forecastData.modifications.reduce((sum, mod) => {
            if (mod.scope === 'interval') return sum + 1;
            if (mod.scope === 'daily') {
              return forecastData.results.filter(r => r.date === mod.date).length;
            }
            if (mod.scope === 'range') {
              const start = new Date(mod.startDate);
              const end = new Date(mod.endDate);
              return forecastData.results.filter(r => {
                const date = new Date(r.date);
                return date >= start && date <= end;
              }).length;
            }
            return sum;
          }, 0)}</p>
        `;
      }
      
      // Update modification details
      const modificationDetails = document.getElementById('modificationDetails');
      if (forecastData.modifications.length === 0) {
        modificationDetails.innerHTML = '<p>No modification details available.</p>';
      } else {
        let html = '<div style="max-height: 200px; overflow-y: auto;">';
        forecastData.modifications.forEach((mod, index) => {
          html += `
            <div style="margin-bottom: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
              <strong>Modification ${index + 1}:</strong>
              <div style="font-size: 12px; margin-top: 4px;">
                Type: ${mod.type === 'volume' ? 'Volume' : 'AHT'}<br>
                Scope: ${mod.scope}<br>
                Value: ${mod.method === 'percentage' ? mod.value + '%' : mod.value}<br>
                Applied: ${mod.timestamp}
              </div>
            </div>
          `;
        });
        html += '</div>';
        modificationDetails.innerHTML = html;
      }
    }

    // Show generating screen
    function showGeneratingScreen(text, subtext) {
      generatingText.textContent = text;
      generatingSubtext.textContent = subtext;
      generatingProgress.style.width = '0%';
      generatingScreen.style.display = 'flex';
    }

    // Update generating progress
    function updateGeneratingProgress(percent, message) {
      generatingProgress.style.width = `${percent}%`;
      generatingSubtext.textContent = message;
    }

    // Hide generating screen
    function hideGeneratingScreen() {
      generatingScreen.style.display = 'none';
    }

    // Show results section
    function showResults() {
      mainContent.style.display = 'none';
      resultsSection.style.display = 'block';
    }

    // Show settings section
    function showSettings() {
      resultsSection.style.display = 'none';
      mainContent.style.display = 'block';
    }

    // Helper functions
    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(line => line.trim());
      if (lines.length === 0) return [];
      
      const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
      const rows = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] ? values[index].trim() : '';
        });
        rows.push(row);
      }
      
      return rows;
    }
    
    function parseDate(dateString) {
      if (!dateString) return new Date();
      return new Date(dateString);
    }
    
    function updateStatus(message, isError = false) {
      statusIndicator.innerHTML = isError 
        ? `<i class="fas fa-exclamation-circle" style="color: var(--bad);"></i> ${message}`
        : `<i class="fas fa-check-circle" style="color: var(--good);"></i> ${message}`;
    }
    
    function clearForecast() {
      forecastData = {
        type: 'manual',
        parameters: {},
        results: null,
        rawData: [],
        modifiedData: [],
        modifications: [],
        originalResults: null,
        intervalView: '60',
        historicalData: null
      };
      
      // Reset form values
      document.getElementById('totalWeeklyVolume').value = 1000;
      document.querySelectorAll('.day-input').forEach((input, index) => {
        const defaults = [16, 17, 17, 17, 17, 10, 6];
        input.value = defaults[index];
      });
      updateDistributionTotal();
      
      // Reset AHT pattern
      document.querySelectorAll('.aht-input').forEach((input, index) => {
        const defaults = [90, 95, 105, 100, 95, 85];
        input.value = defaults[index];
      });
      
      updateStatus('Settings cleared');
    }
    
    function downloadTemplate() {
      const template = `datetime,volume,aht_seconds,queue
2024-01-15 08:00:00,25,350,Voice - Sales
2024-01-15 09:00:00,30,360,Voice - Sales
2024-01-15 10:00:00,35,340,Voice - Sales
2024-01-15 11:00:00,40,330,Voice - Sales
2024-01-15 12:00:00,45,320,Voice - Sales
2024-01-15 13:00:00,40,310,Voice - Sales
2024-01-15 14:00:00,35,300,Voice - Sales
2024-01-15 15:00:00,30,290,Voice - Sales`;
      
      const blob = new Blob([template], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'historical_data_template.csv';
      link.click();
    }
    
    function downloadResults() {
      if (!forecastData.results || forecastData.results.length === 0) {
        alert('No forecast results to download');
        return;
      }
      
      const interval = forecastData.intervalView;
      const data = aggregateDataByInterval(forecastData.results, interval);
      
      const headers = ['Date', 'Time', 'Original_Volume', 'Modified_Volume', 'Original_AHT', 'Modified_AHT', 'Required_Staff', 'FTE', 'Service_Level', 'Occupancy'];
      const rows = data.map(result => [
        result.date,
        result.time,
        Math.round(result.originalVolume || result.volume),
        Math.round(result.volume),
        Math.round(result.originalAht || result.aht),
        Math.round(result.aht),
        Math.round(result.requiredWithShrinkage),
        result.fte.toFixed(3),
        (result.serviceLevel * 100).toFixed(1),
        (result.occupancy * 100).toFixed(1)
      ]);
      
      const csvContent = [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
      
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = `forecast_${interval}_${new Date().toISOString().split('T')[0]}.csv`;
      link.click();
    }

    // Event Listeners
    generateForecastBtn.addEventListener('click', generateForecast);
    clearForecastBtn.addEventListener('click', clearForecast);
    downloadTemplateBtn.addEventListener('click', downloadTemplate);
    backToSettingsBtn.addEventListener('click', showSettings);
    downloadResultsBtn.addEventListener('click', downloadResults);
    erlangInfoBtn.addEventListener('click', () => {
      erlangModal.style.display = 'flex';
    });
    
    distributionInputs.forEach(input => {
      input.addEventListener('input', updateDistributionTotal);
    });
    
    modalCloseBtn.addEventListener('click', () => {
      erlangModal.style.display = 'none';
    });

    erlangModal.addEventListener('click', (e) => {
      if (e.target === erlangModal) {
        erlangModal.style.display = 'none';
      }
    });

    // Prevent form submission
    document.addEventListener('submit', function(e) {
      e.preventDefault();
    });

    // Initialize
    initializePatternVisualization();
    updateDistributionTotal();
    updateStatus('Ready for forecast input');
    
    // Set default forecast type
    forecastData.type = 'manual';
    
    // Initially hide AHT pattern card (it will show for manual tab)
    ahtPatternCard.style.display = 'none';
  </script>
</body>
</html>
